# 测试驱动下的软件生长
最近读完了《Growing Object-Oriented Software, Guided by Tests》的主要章节，中间有个很长的实际项目的例子没耐下心来看完。但即便如此，还是收获颇深的。读完全书最印象深刻的就是反馈的重要性、如何开始"迭代0"、测试代码的本质是什么、与线上代码的区别等。书中关于好代码的想法与之前读完的《Elegant Objects》异曲同工，比如简洁短小、尊重对象的抽象、声明式编程等等。

---

## 1.TDD的根基
### 1.1 快速反馈 
测试驱动开发（TDD），并不是简单地把调整开发和测试的顺序。TDD之所以好用并且流行起来，背后是有其哲学思想做支撑的。说起来有些玄，其实道理很简单，这个思想就是**"实践出真知"**。就好比物理学家做实验来验证其假设，我们程序员也通过实践来验证设计是否可行。那可能很多人会说：编码本身不就是实践吗？设计好了就按照概要和详细设计文档开发不就可以了吗？这里的关键在于：**你能多快得到反馈，从而验证你的想法是可行的**。开发了一大半甚至最后收尾时，发现致命问题或者组合不起来，导致项目延期、返工甚至彻底失败。你也得到了反馈，你也通过实践得到了"真知"，可是代价太大了。那如何才能避免这样的风险呢？答案就是TDD以及其他的敏捷最佳实践。

### 1.2 TDD与原型

工业制造比如手机、汽车等产品，在大规模批量生产前，厂商常常会制造一些所谓原型机。软件工业也是一样的，虽然没有实体，但同样可以受益于这些来自其他行业的最佳实践（另一个大家可能都知道的例子就是建筑行业的设计模式）。之前参与过的一个云存储的项目，就是快速开发出一个原型进行实验和展示。如果的确可行、有前景，再投入更多的资源去开发真正功能齐全、测试完整的产品。

其实TDD与这种原型实验的思想不谋而合。通过TDD的"迭代0"，我们产生一个"空壳"，麻雀虽小五脏俱全，从代码库、基本框架、编译打包、部署到运行环境全都囊括。之后不断迭代添加功能，原型的内容不断丰满，最终变成一个可以发布的产品版本。

下一小节会说到TDD覆盖了开发过程的方方面面，仅从高层次上来说，TDD有两个最大的优势：

1. **做什么**：从业务上，TDD帮助想清楚要"做什么"，而不是跳进细节里想"怎么做"。按照设计文档是不是能做成这样，有没有缺失的部分。从这个方面来讲，TDD促进思考，比如是否还有遗漏的用例，所以应与设计一同进行。
2. **可行吗，合理吗**：从技术上，TDD验证想法是否可行，有没有技术风险。从这个角度来说，TDD还是应该与设计一同进行，而非最终验证甚至推翻原来的设计。

> 这里说个题外话，要夸一下Amazon的开发工具和基础设施。上面"迭代0"里包含的这一整套，除了具体代码内容以外，所有其他的东西都能够通过一两个工具平台在几分钟内搞定。这是什么概念？就是在几分钟内，你就能得到一个具有版本管理、软件包依赖管理的代码库、在AWS里的硬件环境（前提是你有权限和容量）、将这两者关联起来的持续集成Pipeline（CI）、开发任务和Sprint等（而是支持各种主流语言）。后续提交的更改会自动被监控到并CI到你的硬件环境里，做项目不用操心这些麻烦的事情。也许几分钟有点夸张，像申请硬件如果不提前申请Capacity的话可能受审批时间影响，但总体上确实是很厉害。听起来很先进，仔细想想却也是很基础的事情，但要做得这么好确实不容易。就像我们个人的学习一样，基本功看起来简单，要做扎实了不容易！这里不能介绍太多，请自行查找资料，比如这篇[The Story of Apollo](https://www.allthingsdistributed.com/2014/11/apollo-amazon-deployment-engine.html)以及开放出来的服务[CodeDeploy和CodePipeline](https://aws.amazon.com/blogs/aws/now-available-aws-codepipeline/)。

### 1.3 嵌套的循环



## 2.TDD的本质

上一节讲到TDD的根基是反馈，只有能产生有效的反馈，才能真正达到效果。而效果就是帮助我们思考要做什么、设计得是否合理。最终得到用户想要的也是我们想做的，并且合理的设计方案。那么TDD的本质到底是什么呢？很显然，TDD是由测试用例组成，而用例也就是测试代码。那看起来很配角的测试代码是怎样起到这么大作用的呢？答案就是**"欲穷千里目，更上一层楼"**。TDD的本质就是从高一层次上去看问题：

1. **接口之外看接口**：因为TDD是先有测试代码，通过创建空的类和接口方法解决编译错误，然后再逐步迭代通过更多的用例来为被测试类添加实现细节。从接口之外看接口，从而达到帮助我们思考做什么的目的。
2. **代码质量的信号灯**：我们完全可以把测试代码看作是被测试类的另一个使用者，这种想法上的转变是颠覆性的。
   1. **低耦合**：在测试的`setup方法`我们通常要做准备工作，比如mock对象等，这些信息也叫做类的context上下文。context越简单，类越容易被重用，所以TDD帮你理清了被测试类的dependency。
   2. **高内聚**：此外，`assert`写起来清晰而容易，说明被测试类有明确的职责。
3. **可执行的文档**：读测试代码的频率应该高于线上代码，它可以产生或者它本身就是软件的使用文档，说明了每个功能的"通信协议"或"规约"，比如传入什么样的参数就能得到什么样的返回值。



可读性



一定的抽象性



灵活性