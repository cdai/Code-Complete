# 红宝书：算法设计手册

## 1.算法基础
### 1.1 基本概念
算法是用来解决一个通用的、良好定义问题的一系列计算步骤。所以要实现算法，**首先要将待解决的问题明确清晰地定义好**。先要明确的一点，就是问题与问题实例的区别。比如一个数组排序算法，一个输入实例是[1,3,0]，输出实例是[0,1,3]。下面是排序算法的问题描述：

```
Problem: Sorting
Input: A sequence of n keys A1, ..., An
Output: The permutation of the input sequence such that A1’ <= A2’ <= ... <= An’
```

可以看出Input和Output部分是对所有实例的抽象。而算法就是对任何输入实例，都能产生期望的输出实例。而正确性只是我们对一个好算法的最基本标准，除此之外我们还希望它高效，并且容易实现。

### 1.2 通用性
算法一定是具有通用性的，越通用也就意味着前提假设越少，算法能解决的问题越多越广。但有时越通用的问题越难解决，所以我们要加上假设，**限制算法能够解决的问题实例的个数**。

### 1.2 正确性
明显是最大的敌人。当我们觉得一个算法符合直觉，"明显"是正确的话，我们很可能被表面蒙蔽了。两个经典的例子，一是总是选当前结点的最短路径来解决旅行商问题，二是调度始终选择最先开始或最短的任务。看似正确的算法，一个反例就能立即将其杀死。**寻找反例是算法设计中的重要一环，好的算法经常就在此**。寻找反例也是有一些技巧的：

* **小处着手（Think Small）**：业余者设计复杂的例子，然后绝望地盯着它。专家从几个最简单的例子入手，去验证和推理，寻找反例。
* **穷尽思考（Think Exhaustively）**：简单的例子意味着输入规模N非常小，这也使得穷尽法成为可能。
* **专攻弱点（Hunt for the Weakness）**：如果一个算法使用贪婪策略，始终取最大，思考为什么它可能是错的。
* **设计平局（Go for a Tie）**：让所有东西都相等，看算法如何继续，是否会返回次优解。
* **极端情况（Seek Extremes）**：许多反例都是最大最小、最左最右、最远最近的混合。

没法找到反例并不能说明算法是正确的，我们要正式地证明其正确性。"计算机科学家是只会用归纳法证明的数学家"。这种说法部分准确，因为计算机科学家比较"懒"，但主要原因是许多算法都是递归或者递增的。关于算法与归纳法，最好的参考就是《Introduction to Algorithms: A Creative Approach》。

### 1.3 性能分析

RAM模型和Big O


## 2.数据结构
